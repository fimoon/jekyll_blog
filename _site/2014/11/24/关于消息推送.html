<!DOCTYPE html>
<html>
<head>
　　<meta http-equiv="content-type" content="text/html; charset=utf-8" />
　　<title>站内消息的实现与思考</title>
	<link rel="stylesheet" href="/css/syntax.css" type="text/css" media="screen" />
	<link rel="stylesheet" href="/style/content.css" />
	<link rel="stylesheet" href="http://cdn.bootcss.com/highlight.js/8.0/styles/monokai_sublime.min.css" />
	<script type="text/javascript" src="http://cdn.bootcss.com/highlight.js/8.0/highlight.min.js"></script>
</head>
<body>



<div class="content">
	<h2>站内消息的实现与思考</h2>
	<h6>24 Nov 2014&nbsp;&nbsp;&nbsp;[业务,思考]</h6>

	<div class="PageNavigation">
	  
	    <a class="prev" href="/2014/10/21/%E5%85%B3%E4%BA%8E%E5%BC%80%E5%8D%9A%E5%AE%A2.html">&laquo; 关于开博客</a>
	  
	  
	    <a class="next" href="/2014/11/25/php%E6%98%AF%E4%B8%8D%E6%98%AF%E5%BA%94%E8%AF%A5%E6%98%AF%E5%89%8D%E7%AB%AF%E8%AF%AD%E8%A8%80.html">php是不是应该是前端语言？ &raquo;</a>
	  
	</div>

	<div class="content-wrap">
	"咱们做一个推送的功能吧？"
	"什么推送？"
	"就是能给用户一些提示，站内的消息！"
	"好的没问题！"
	"那好，这两天没啥事就上了吧"
	"ok!"

	然后，我就开始做这个需求，首先消息肯定需要一个表的，字段需要from，to，title，content，status(已读，未读
)，最多加上一个createTime，upadteTime方便统计和数据的整理，所以字段设计如下：

    user_from:  发送者
    user_to:    接受者
    title:      标题
    content:    内容
    status:     状态（已读，未读）
    createTime: 创建时间
    updateTime: 修改时间

	搞完之后就开始开心的写代码了，无非就是把发送消息变成数据库中create一条新纪录嘛，群发怎么办？群发当
然只是插入一条！我当然不会傻到为百分之二的活跃用户来浪费百分之九十八的空间……

	当时这个产品的注册用户有四万，每天的活跃用户也就八百多

	准备用一个特殊的字段表示所有用户，注册一个特殊的用户来表示所有管理员，还起了个名字叫小秘书。

	感觉一切都很完美，可是真的开始做了之后才发现，卧槽！！！！

	我怎么表示已读未读？？也就是类似于微信的那个小红点，单发还好说，我直接把状态改过来就可以，可是群发？？

	一条消息，张三读过，可是李四未必读过！我要记录下到底有谁读过这条消息，可是，记在哪里？

	中间表？可是有现在就有四万用户！每一次群发都要往数据插入四万条记录！！！

	不做群发？ 这个需要跟产品负责人说一下。。。

	哎，当时不该吹那么大牛！！

	……

	于是我开始了以下的思考：

	1. 这个问题不是不可以做，考虑到效率，空间，做起来会蛋疼。
	2. 这个东西需要记录每个用户的状态，但是无法用客户端的东西（不是APP，也不用cookie）
	3. 一条消息只是对登陆的用户才有意义，对僵尸用户是没有意义的，所以不会记录四万条记录
	4. 如何只记录登陆用户的消息信息？当然是在登陆的时候去查询。
	5. 这样我就需要在每次登陆的时候，首先从中间表拿到用户的消息读取情况，然后用这个集合与消息列表
	   做减法，求出未读消息数目
	6. 5的做法会不会比较复杂？而且每次登陆的都要做两次查询，一次内存中的集合运算，可能还要有一次
		插入，效率的问题可以用redis这种内存数据库来解决
	7. 会不会，这个东西必然要牺牲一些东西来作权衡？
	8. 哪里牺牲呢？消息？？ 对！消息是由时效性的。
	9. 消息需要有一个超时时间，这下就好说了

	于是，我删掉刚建好的中间表，在原来的表上加上了一个字段
		expire_at: 什么时候超时

	借助于内存数据库，这个需求应该可以实现了：

	1. 首先是群发消息，数据库中会插入一条 user_to: all 的数据, 假设ID为888
	2. ID为666的用户登陆
		redis中没有记录：根据status从数据库中拿出所有消息，当然包括888，当用户已
	读888消息的时候，set(888:666, 1), expireAt(888:666, 888.expire_at)
		redis中有记录：已读消息数目减一，并且知道是888这条记录
	3. 拉出用户消息的时候，要注意考虑超时时间，缓存，状态这里的操作会比较复杂


	</div>
	<div class="ds-thread" data-thread-key="" data-title="heloworld" data-url="">
	</div>
</div>

</body>
<script type="text/javascript">
	// 代码高亮
	hljs.initHighlightingOnLoad();

	var duoshuoQuery = {short_name:"fimoonme"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0]
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
</script>
</html>